#include "spdk/env.h"
#include "spdk/fs.h"
#include "spdk/thread.h"
#include "spdk/blob_bdev.h"
#include <iostream>
#include <vector>
#include <cstring>
#include <stdexcept>

class SPDKFsdevBatchReader {
public:
    SPDKFsdevBatchReader(const char *bdev_name);
    ~SPDKFsdevBatchReader();

    void init();
    void loadFilesystem();
    void batchRead(const char *filename, size_t num_batches, size_t batch_size);
    
private:
    struct spdk_filesystem *fs;
    struct spdk_fs_thread_ctx *fs_thread_ctx;
    struct spdk_bs_dev *bs_dev;
    struct spdk_bdev *bdev;
    const char *bdev_name;

    // Callbacks
    static void fsLoadCb(void *ctx, int fserrno, struct spdk_filesystem *fs);
    static void blobstoreBdevInitCb(void *ctx, struct spdk_bs_dev *bs_dev, int bserrno);
    static void readCompleteCb(void *ctx, int status);
    
    // Helper functions
    void mountFilesystem();
};

SPDKFsdevBatchReader::SPDKFsdevBatchReader(const char *bdev_name)
    : fs(nullptr), fs_thread_ctx(nullptr), bs_dev(nullptr), bdev(nullptr), bdev_name(bdev_name) {
    spdk_env_opts opts;
    spdk_env_opts_init(&opts);
    if (spdk_env_init(&opts) != 0) {
        throw std::runtime_error("Failed to initialize SPDK environment.");
    }
}

SPDKFsdevBatchReader::~SPDKFsdevBatchReader() {
    if (fs_thread_ctx) {
        spdk_fs_free_thread_ctx(fs_thread_ctx);
    }
    if (fs) {
        spdk_fs_unload(fs, nullptr, nullptr);
    }
    spdk_env_fini();
}

void SPDKFsdevBatchReader::init() {
    bdev = spdk_bdev_get_by_name(bdev_name);
    if (bdev == nullptr) {
        throw std::runtime_error("Failed to find bdev.");
    }

    spdk_bdev_create_bs_dev(bdev, SPDKFsdevBatchReader::blobstoreBdevInitCb, this);
}

void SPDKFsdevBatchReader::loadFilesystem() {
    if (!bs_dev) {
        throw std::runtime_error("Blobstore device is not initialized.");
    }

    spdk_fs_load(fs, bs_dev, SPDKFsdevBatchReader::fsLoadCb, this);
}

void SPDKFsdevBatchReader::fsLoadCb(void *ctx, int fserrno, struct spdk_filesystem *fs) {
    if (fserrno != 0) {
        std::cerr << "Failed to load filesystem: " << fserrno << std::endl;
        return;
    }

    SPDKFsdevBatchReader *reader = static_cast<SPDKFsdevBatchReader *>(ctx);
    reader->fs = fs;
    reader->fs_thread_ctx = spdk_fs_alloc_thread_ctx(fs);
    std::cout << "Filesystem loaded successfully!" << std::endl;
}

void SPDKFsdevBatchReader::blobstoreBdevInitCb(void *ctx, struct spdk_bs_dev *bs_dev, int bserrno) {
    if (bserrno != 0) {
        std::cerr << "Failed to initialize blobstore device: " << bserrno << std::endl;
        return;
    }

    SPDKFsdevBatchReader *reader = static_cast<SPDKFsdevBatchReader *>(ctx);
    reader->bs_dev = bs_dev;
    reader->loadFilesystem();
}

void SPDKFsdevBatchReader::readCompleteCb(void *ctx, int status) {
    if (status == 0) {
        std::cout << "Read operation completed successfully!" << std::endl;
    } else {
        std::cerr << "Read operation failed with status: " << status << std::endl;
    }
}

void SPDKFsdevBatchReader::batchRead(const char *filename, size_t num_batches, size_t batch_size) {
    if (!fs || !fs_thread_ctx) {
        throw std::runtime_error("Filesystem not loaded or thread context not allocated.");
    }

    struct spdk_file *file;
    int rc = spdk_fs_open_file(fs, fs_thread_ctx, filename, SPDK_BLOBFS_OPEN_CREATE, &file);
    if (rc != 0) {
        throw std::runtime_error("Failed to open file.");
    }

    size_t total_size = num_batches * batch_size;
    std::vector<char> buffer(total_size);
    
    size_t offset = 0;
    for (size_t i = 0; i < num_batches; ++i) {
        spdk_file_read_async(file, fs_thread_ctx, buffer.data() + offset, offset, batch_size, SPDKFsdevBatchReader::readCompleteCb, nullptr);
        offset += batch_size;
    }

    // Poll thread to complete requests
    spdk_thread_poll(spdk_get_thread(), 0, 0);

    spdk_file_close(file, fs_thread_ctx);
}

int main(int argc, char **argv) {
    try {
        const char *bdev_name = "Nvme0n1";
        SPDKFsdevBatchReader reader(bdev_name);
        
        reader.init();
        reader.batchRead("/testfile", 4, 4096);  // 4 批次，每次读 4KB
        
    } catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return -1;
    }
    
    return 0;
}
