#include <iostream>  
#include <vector>  
#include <fstream>  
#include <string>  
//分片
int main() {  
    // 定义文件路径  
    std::vector<std::string> paths{  
        "disk.index1",  
        "disk.index2",  
        "disk.index3",  
        "disk.index4",  
        "disk.index5"  
    };  
    
    // 假设npts_64是要写入的数据点总数  
    uint64_t npts_64 = 23; // 示例总数据点  
    
    size_t num_files = paths.size();  
    size_t base_size = npts_64 / num_files; // 每个文件的基本写入量  
    
    // 创建ofstream对象，打开所有文件  
    std::vector<std::ofstream> diskann_writers(num_files);  
    for (size_t j = 0; j < num_files; ++j) {  
        diskann_writers[j].open(paths[j], std::ios::binary | std::ios::app);  
        if (!diskann_writers[j].is_open()) {  
            std::cerr << "Failed to open file: " << paths[j] << std::endl;  
            return 1; // 如果文件打开失败，退出  
        }  
    }  
    
    // 用于跟踪当前写入的文件索引  
    size_t current_file_index = 0;  
    
    for (uint64_t i = 0; i < npts_64; i++) {  
        // 确定当前文件应该写入的条数  
        size_t current_write_limit = (current_file_index < num_files - 1) ? base_size : (npts_64 - (base_size * (num_files - 1)));  
        
        // 每当达到当前文件的写入限制时，就切换到下一个文件  
        if (i > 0 && i % (base_size) == 0 && current_file_index < num_files - 1) {  
            current_file_index++; // 切换到下一个文件  
        }  
        
        // 写入数据  
        std::string data = "test data " + std::to_string(i) + "\n"; // 每条数据后面加上换行符  
        diskann_writers[current_file_index].write(data.c_str(), data.size());  
    }  
    
    // 关闭所有文件  
    for (size_t j = 0; j < num_files; ++j) {  
        diskann_writers[j].close();  
    }  
    
    // 打印每个文件的内容进行验证  
    for (const auto& path : paths) {  
        std::cout << "Contents of " << path << ":\n";  
        std::ifstream file(path);  
        std::string line;  
        while (std::getline(file, line)) {  
            std::cout << line << std::endl;  
        }  
        file.close();  
        std::cout << "\n"; // 输出换行以便更好地读出内容  
    }  
    
    return 0;  
}


// 查找
#include <iostream>  
#include <vector>  
#include <fstream>  
#include <string>  

int main() {  
    // 模拟输入数据  
    const size_t total_data_points = 23; // 总数据量  
    const size_t num_files = 5; // 文件数量  
    const size_t arr[total_data_points] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10,   
                                           11, 12, 13, 14, 15, 16, 17, 18, 19, 20,   
                                           21, 22, 23};  
    
    // 计算基本写入量  
    size_t base_size = total_data_points / num_files; // 每个文件的基本条数  
    size_t extra_data = total_data_points % num_files; // 多余的数据条目  
    
    // 输入要查找的数据  
    size_t data_to_find = 21; // 查找数据 arr[21]  
    
    // 计算目标数据所处的分片  
    size_t file_index = data_to_find / base_size; // 计算文件索引  
    if (file_index >= extra_data) { // 如果是在前面的文件以外  
        file_index = file_index; // 基本不变  
    } else {  
        // 否则为特殊情况：前面的文件每个都是 base_size + 1  
        file_index = file_index; // 仍然不需要调整  
    }  
    
    // 计算在该文件中的条目索引  
    size_t entry_index = data_to_find - (file_index * base_size) - (file_index < extra_data ? file_index : extra_data);  
    
    // 打印查找结果  
    std::cout << "Data 'arr[" << data_to_find << "]' is in file index: " << file_index  
              << ", and its index in that file is: " << entry_index << std::endl;  
    
    // 读取并打印数据  
    std::cout << "Found data: " << arr[data_to_find] << std::endl;  
    
    return 0;  
}
