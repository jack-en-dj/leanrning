#include <arm_neon.h>  

float DistanceL2Int8_compare(const int8_t *a, const int8_t *b, uint32_t size) {  
    float32x4_t r = vdupq_n_f32(0.0f); // 初始化结果为0  
    const int8_t *pX = a;  
    const int8_t *pY = b;  

    // 处理每次16字节（16个8位整数）  
    while (size >= 16) {  
        int8x16_t x = vld1q_s8(pX); // 加载16个8位带符号整数  
        int8x16_t y = vld1q_s8(pY); // 加载16个8位带符号整数  
        int8x16_t r1 = vsubq_s8(x, y); // 逐元素相减  

        // 计算平方并累加  
        int16x8_t squared_low = vmull_s8(vget_low_s8(r1), vget_low_s8(r1)); // 处理低8个元素  
        int16x8_t squared_high = vmull_s8(vget_high_s8(r1), vget_high_s8(r1)); // 处理高8个元素  

        // 将平方值转换为float并累加  
        float32x4_t r_squared_low = vcvtq_f32_s32(vget_low_s32(squared_low));  
        float32x4_t r_squared_high = vcvtq_f32_s32(vget_low_s32(squared_high));  
        
        r = vaddq_f32(r, r_squared_low);  
        r = vaddq_f32(r, r_squared_high);  

        pX += 16;  
        pY += 16;  
        size -= 16;  
    }  

    // 处理剩余的8字节  
    while (size >= 8) {  
        int8x8_t x = vld1_s8(pX); // 加载8个8位带符号整数  
        int8x8_t y = vld1_s8(pY); // 加载8个8位带符号整数  
        int8x8_t r2 = vsub_s8(x, y); // 逐元素相减  

        // 计算平方  
        int16x8_t squared = vmull_s8(r2, r2);  
        float32x4_t r_squared = vcvt_f32_s32(vget_low_s32(squared));  
        
        r = vaddq_f32(r, r_squared);  

        pX += 8;  
        pY += 8;  
        size -= 8;  
    }  

    // 处理剩余的4字节  
    while (size >= 4) {  
        int8x4_t x = vld1_s8(pX); // 加载4个8位带符号整数  
        int8x4_t y = vld1_s8(pY); // 加载4个8位带符号整数  
        int8x4_t r2 = vsub_s8(x, y); // 逐元素相减  

        // 计算平方  
        int16x4_t squared = vmull_s8(r2, r2);  
        float32x4_t r_squared = vcvt_f32_s32(squared);  
        
        r = vaddq_f32(r, r_squared);  

        pX += 4;  
        pY += 4;  
        size -= 4;  
    }  

    // 最后将结果归约  
    float32x2_t sum = vadd_f32(vget_low_f32(r), vget_high_f32(r));  
    sum = vpadd_f32(sum, sum); // 水平加法  
    return vget_lane_f32(sum, 0); // 返回结果  
}



#include <arm_neon.h>  

float DistanceL2Float_compare(const float *a, const float *b, uint32_t size) const {  
    float32x4_t sum = vdupq_n_f32(0.0f); // 初始化结果为0  
    uint32_t niters = size / 8; // 假设 size 可被 8 整除  

    for (uint32_t j = 0; j < niters; j++) {  
        // 每次处理8个浮点数  
        const float *a_ptr = a + 8 * j;  
        const float *b_ptr = b + 8 * j;  

        // 预读下一个8个元素 (不完全需要，因为NEON没有直接的预取指令，但可以考虑)  
        if (j < (niters - 1)) {  
            __builtin_prefetch(a_ptr + 8, 0, 3);  
            __builtin_prefetch(b_ptr + 8, 0, 3);  
        }  

        // 加载8个浮点数  
        float32x4_t a_vec1 = vld1q_f32(a_ptr);       // 读入 a[0:3]  
        float32x4_t a_vec2 = vld1q_f32(a_ptr + 4);   // 读入 a[4:7]  
        float32x4_t b_vec1 = vld1q_f32(b_ptr);       // 读入 b[0:3]  
        float32x4_t b_vec2 = vld1q_f32(b_ptr + 4);   // 读入 b[4:7]  

        // 计算 (a - b)  
        float32x4_t tmp_vec1 = vsubq_f32(a_vec1, b_vec1);  
        float32x4_t tmp_vec2 = vsubq_f32(a_vec2, b_vec2);  

        // 计算平方并累加  
        sum = vaddq_f32(sum, vmulq_f32(tmp_vec1, tmp_vec1));  
        sum = vaddq_f32(sum, vmulq_f32(tmp_vec2, tmp_vec2));  
    }  

    // 水平加法以合并 sum  
    float32x2_t sum_low = vget_low_f32(sum);  
    float32x2_t sum_high = vget_high_f32(sum);  
    sum_low = vadd_f32(sum_low, sum_high); // 合并高低部分  
    sum_low = vpadd_f32(sum_low, sum_low); // 最后将两部分再相加  

    return vget_lane_f32(sum_low, 0); // 返回最终结果  
}



#include <arm_neon.h>  
#include <stdexcept>  
#include <type_traits>  
#include <iostream>  

template <typename T>  
class DistanceInnerProduct {  
public:  
    float inner_product(const T *a, const T *b, uint32_t size) const;  
};  

template <typename T>  
float DistanceInnerProduct<T>::inner_product(const T *a, const T *b, uint32_t size) const {  
    if (!std::is_floating_point<T>::value) {  
        std::cerr << "ERROR: Inner Product only defined for float currently." << std::endl;  
        throw std::runtime_error("ERROR: Inner Product only defined for float currently.");  
    }  

    float32x4_t sum = vdupq_n_f32(0.0f); // 初始化结果为0  

    uint32_t D = (size + 3) & ~3U; // 向上对齐到4的倍数  
    uint32_t DR = D % 8;           // 不足8个元素的剩余部分  
    uint32_t DD = D - DR;          // 可处理的元素数量  
    const float *l = a;  
    const float *r = b;  

    // 处理剩余元素（<= 4）  
    if (DR) {  
        for (uint32_t i = 0; i < DR; i += 4) {  
            float32x4_t a_vec = vld1q_f32(l + i);  
            float32x4_t b_vec = vld1q_f32(r + i);  
            sum = vmlaq_f32(sum, a_vec, b_vec); // sum += a_vec * b_vec  
        }  
    }  

    // 主循环处理每16个原始元素  
    for (uint32_t i = 0; i < DD; i += 8, l += 8, r += 8) {  
        // 加载8个元素  
        float32x4_t a_vec1 = vld1q_f32(l);   // 前4个元素  
        float32x4_t b_vec1 = vld1q_f32(r);   // 前4个元素  
        float32x4_t a_vec2 = vld1q_f32(l + 4); // 后4个元素  
        float32x4_t b_vec2 = vld1q_f32(r + 4); // 后4个元素  

        // 计算内积  
        sum = vmlaq_f32(sum, a_vec1, b_vec1); // sum += a_vec1 * b_vec1  
        sum = vmlaq_f32(sum, a_vec2, b_vec2); // sum += a_vec2 * b_vec2  
    }  

    // 水平加法合并结果  
    float32x2_t sum_low = vget_low_f32(sum);  
    float32x2_t sum_high = vget_high_f32(sum);  
    sum_low = vadd_f32(sum_low, sum_high); // 合并高低部分  
    sum_low = vpadd_f32(sum_low, sum_low);  // 最后将两部分再相加  

    return vget_lane_f32(sum_low, 0); // 返回最终的内积  
}



#include <arm_neon.h>  
#include <stdexcept>  
#include <type_traits>  
#include <iostream>  

template <typename T>  
class DistanceFastL2 {  
public:  
    float norm(const T *a, uint32_t size) const;  
};  

template <typename T>  
float DistanceFastL2<T>::norm(const T *a, uint32_t size) const {  
    if (!std::is_floating_point<T>::value) {  
        std::cerr << "ERROR: FastL2 only defined for float currently." << std::endl;  
        throw std::runtime_error("ERROR: FastL2 only defined for float currently.");  
    }  

    float32x4_t sum = vdupq_n_f32(0.0f); // 初始化结果为0  

    // 确保size是4的倍数，如果不是则向上对齐  
    uint32_t D = (size + 3) & ~3U;  
    uint32_t DR = D % 8; // 对8元素的剩余部分  
    uint32_t DD = D - DR; // 可处理的元素数量  
    const float *l = a;  

    // 处理剩余元素（最多4个元素）  
    if (DR) {  
        for (uint32_t i = 0; i < DR; i += 4) {  
            float32x4_t a_vec = vld1q_f32(l + i);  
            sum = vmlaq_f32(sum, a_vec, a_vec); // sum += a_vec * a_vec  
        }  
    }  

    // 主循环处理每8个原始元素  
    for (uint32_t i = 0; i < DD; i += 8, l += 8) {  
        // 加载8个浮点数  
        float32x4_t a_vec1 = vld1q_f32(l);   // 前4个  
        float32x4_t a_vec2 = vld1q_f32(l + 4); // 后4个  

        // 计算L2范数 (平方和)  
        sum = vmlaq_f32(sum, a_vec1, a_vec1); // sum += a_vec1 * a_vec1  
        sum = vmlaq_f32(sum, a_vec2, a_vec2); // sum += a_vec2 * a_vec2  
    }  

    // 水平加法合并所有结果  
    float32x2_t sum_low = vget_low_f32(sum);  
    float32x2_t sum_high = vget_high_f32(sum);  
    sum_low = vadd_f32(sum_low, sum_high); // 合并高低部分  
    sum_low = vpadd_f32(sum_low, sum_low);  // 最后将两部分再相加  

    return sqrtf(vget_lane_f32(sum_low, 0)); // 返回最终的L2范数  
}


#include <arm_neon.h>  
#include <stdexcept>  
#include <iostream>  

class NEONDistanceInnerProductFloat {  
public:  
    float compare(const float *a, const float *b, uint32_t size) const;  
};  

float NEONDistanceInnerProductFloat::compare(const float *a, const float *b, uint32_t size) const {  
    float32x4_t sum = vdupq_n_f32(0.0f); // 初始化结果为0  

    // 处理大小对齐  
    uint32_t D = (size + 3) & ~3U; // 向上对齐到4的倍数  
    uint32_t DR = D % 8; // 最后处理剩余的元素  
    uint32_t DD = D - DR; // 可处理的元素数量  

    const float *l = a;  
    const float *r = b;  

    // 处理剩余元素（最多3个元素）  
    if (DR) {  
        for (uint32_t i = 0; i < DR; i += 4) {  
            float32x4_t a_vec = vld1q_f32(l + i); // 加载a  
            float32x4_t b_vec = vld1q_f32(r + i); // 加载b  
            sum = vmlaq_f32(sum, a_vec, b_vec);   // sum += a_vec * b_vec  
        }  
    }  

    // 主循环，每次处理8个元素  
    for (uint32_t i = 0; i < DD; i += 8, l += 8, r += 8) {  
        // 加载8个浮点数  
        float32x4_t a_vec1 = vld1q_f32(l);       // 前4个  
        float32x4_t a_vec2 = vld1q_f32(l + 4);   // 后4个  
        float32x4_t b_vec1 = vld1q_f32(r);       // 前4个  
        float32x4_t b_vec2 = vld1q_f32(r + 4);   // 后4个  
        
        // 更新sum  
        sum = vmlaq_f32(sum, a_vec1, b_vec1); // sum += a_vec1 * b_vec1  
        sum = vmlaq_f32(sum, a_vec2, b_vec2); // sum += a_vec2 * b_vec2  
    }  

    // 水平加法合并结果  
    float32x2_t sum_low = vget_low_f32(sum);  
    float32x2_t sum_high = vget_high_f32(sum);  
    sum_low = vadd_f32(sum_low, sum_high); // 合并低高部分  
    sum_low = vpadd_f32(sum_low, sum_low);  // 最后将两部分再相加  

    return vget_lane_f32(sum_low, 0); // 返回最终内积的结果  
}
